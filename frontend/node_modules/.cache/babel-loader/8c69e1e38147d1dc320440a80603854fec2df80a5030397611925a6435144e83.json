{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { ApolloLink } from \"../../../link/core/index.js\";\nimport { Observable, addTypenameToDocument, removeClientSetsFromDocument, cloneDeep, stringifyForDisplay, print, getOperationDefinition, getDefaultValues, removeDirectivesFromDocument, checkDocument } from \"../../../utilities/index.js\";\nfunction requestToKey(request, addTypename) {\n  var queryString = request.query && print(addTypename ? addTypenameToDocument(request.query) : request.query);\n  var requestKey = {\n    query: queryString\n  };\n  return JSON.stringify(requestKey);\n}\nvar MockLink = /** @class */function (_super) {\n  __extends(MockLink, _super);\n  function MockLink(mockedResponses, addTypename, options) {\n    if (addTypename === void 0) {\n      addTypename = true;\n    }\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n    var _a;\n    var _this = _super.call(this) || this;\n    _this.addTypename = true;\n    _this.showWarnings = true;\n    _this.mockedResponsesByKey = {};\n    _this.addTypename = addTypename;\n    _this.showWarnings = (_a = options.showWarnings) !== null && _a !== void 0 ? _a : true;\n    if (mockedResponses) {\n      mockedResponses.forEach(function (mockedResponse) {\n        _this.addMockedResponse(mockedResponse);\n      });\n    }\n    return _this;\n  }\n  MockLink.prototype.addMockedResponse = function (mockedResponse) {\n    var normalizedMockedResponse = this.normalizeMockedResponse(mockedResponse);\n    var key = requestToKey(normalizedMockedResponse.request, this.addTypename);\n    var mockedResponses = this.mockedResponsesByKey[key];\n    if (!mockedResponses) {\n      mockedResponses = [];\n      this.mockedResponsesByKey[key] = mockedResponses;\n    }\n    mockedResponses.push(normalizedMockedResponse);\n  };\n  MockLink.prototype.request = function (operation) {\n    var _this = this;\n    var _a;\n    this.operation = operation;\n    var key = requestToKey(operation, this.addTypename);\n    var unmatchedVars = [];\n    var requestVariables = operation.variables || {};\n    var mockedResponses = this.mockedResponsesByKey[key];\n    var responseIndex = mockedResponses ? mockedResponses.findIndex(function (res, index) {\n      var mockedResponseVars = res.request.variables || {};\n      if (equal(requestVariables, mockedResponseVars)) {\n        return true;\n      }\n      if (res.variableMatcher && res.variableMatcher(operation.variables)) {\n        return true;\n      }\n      unmatchedVars.push(mockedResponseVars);\n      return false;\n    }) : -1;\n    var response = responseIndex >= 0 ? mockedResponses[responseIndex] : void 0;\n    // There have been platform- and engine-dependent differences with\n    // setInterval(fn, Infinity), so we pass 0 instead (but detect\n    // Infinity where we call observer.error or observer.next to pend\n    // indefinitely in those cases.)\n    var delay = (response === null || response === void 0 ? void 0 : response.delay) === Infinity ? 0 : (_a = response === null || response === void 0 ? void 0 : response.delay) !== null && _a !== void 0 ? _a : 0;\n    var configError;\n    if (!response) {\n      configError = new Error(\"No more mocked responses for the query: \".concat(print(operation.query), \"\\nExpected variables: \").concat(stringifyForDisplay(operation.variables), \"\\n\").concat(unmatchedVars.length > 0 ? \"\\nFailed to match \".concat(unmatchedVars.length, \" mock\").concat(unmatchedVars.length === 1 ? \"\" : \"s\", \" for this query. The mocked response had the following variables:\\n\").concat(unmatchedVars.map(function (d) {\n        return \"  \".concat(stringifyForDisplay(d));\n      }).join(\"\\n\"), \"\\n\") : \"\"));\n      if (this.showWarnings) {\n        console.warn(configError.message + \"\\nThis typically indicates a configuration error in your mocks \" + \"setup, usually due to a typo or mismatched variable.\");\n      }\n    } else {\n      if (response.maxUsageCount && response.maxUsageCount > 1) {\n        response.maxUsageCount--;\n      } else {\n        mockedResponses.splice(responseIndex, 1);\n      }\n      var newData = response.newData;\n      if (newData) {\n        response.result = newData(operation.variables);\n        mockedResponses.push(response);\n      }\n      if (!response.result && !response.error && response.delay !== Infinity) {\n        configError = new Error(\"Mocked response should contain either `result`, `error` or a `delay` of `Infinity`: \".concat(key));\n      }\n    }\n    return new Observable(function (observer) {\n      var timer = setTimeout(function () {\n        if (configError) {\n          try {\n            // The onError function can return false to indicate that\n            // configError need not be passed to observer.error. For\n            // example, the default implementation of onError calls\n            // observer.error(configError) and then returns false to\n            // prevent this extra (harmless) observer.error call.\n            if (_this.onError(configError, observer) !== false) {\n              throw configError;\n            }\n          } catch (error) {\n            observer.error(error);\n          }\n        } else if (response && response.delay !== Infinity) {\n          if (response.error) {\n            observer.error(response.error);\n          } else {\n            if (response.result) {\n              observer.next(typeof response.result === \"function\" ? response.result(operation.variables) : response.result);\n            }\n            observer.complete();\n          }\n        }\n      }, delay);\n      return function () {\n        clearTimeout(timer);\n      };\n    });\n  };\n  MockLink.prototype.normalizeMockedResponse = function (mockedResponse) {\n    var _a;\n    var newMockedResponse = cloneDeep(mockedResponse);\n    var queryWithoutClientOnlyDirectives = removeDirectivesFromDocument([{\n      name: \"connection\"\n    }, {\n      name: \"nonreactive\"\n    }, {\n      name: \"unmask\"\n    }], checkDocument(newMockedResponse.request.query));\n    invariant(queryWithoutClientOnlyDirectives, 75);\n    newMockedResponse.request.query = queryWithoutClientOnlyDirectives;\n    var query = removeClientSetsFromDocument(newMockedResponse.request.query);\n    if (query) {\n      newMockedResponse.request.query = query;\n    }\n    mockedResponse.maxUsageCount = (_a = mockedResponse.maxUsageCount) !== null && _a !== void 0 ? _a : 1;\n    invariant(mockedResponse.maxUsageCount > 0, 76, mockedResponse.maxUsageCount);\n    this.normalizeVariableMatching(newMockedResponse);\n    return newMockedResponse;\n  };\n  MockLink.prototype.normalizeVariableMatching = function (mockedResponse) {\n    var request = mockedResponse.request;\n    if (mockedResponse.variableMatcher && request.variables) {\n      throw new Error(\"Mocked response should contain either variableMatcher or request.variables\");\n    }\n    if (!mockedResponse.variableMatcher) {\n      request.variables = __assign(__assign({}, getDefaultValues(getOperationDefinition(request.query))), request.variables);\n      mockedResponse.variableMatcher = function (vars) {\n        var requestVariables = vars || {};\n        var mockedResponseVariables = request.variables || {};\n        return equal(requestVariables, mockedResponseVariables);\n      };\n    }\n  };\n  return MockLink;\n}(ApolloLink);\nexport { MockLink };\n// Pass in multiple mocked responses, so that you can test flows that end up\n// making multiple queries to the server.\n// NOTE: The last arg can optionally be an `addTypename` arg.\nexport function mockSingleLink() {\n  var mockedResponses = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    mockedResponses[_i] = arguments[_i];\n  }\n  // To pull off the potential typename. If this isn't a boolean, we'll just\n  // set it true later.\n  var maybeTypename = mockedResponses[mockedResponses.length - 1];\n  var mocks = mockedResponses.slice(0, mockedResponses.length - 1);\n  if (typeof maybeTypename !== \"boolean\") {\n    mocks = mockedResponses;\n    maybeTypename = true;\n  }\n  return new MockLink(mocks, maybeTypename);\n}","map":{"version":3,"names":["invariant","equal","ApolloLink","Observable","addTypenameToDocument","removeClientSetsFromDocument","cloneDeep","stringifyForDisplay","print","getOperationDefinition","getDefaultValues","removeDirectivesFromDocument","checkDocument","requestToKey","request","addTypename","queryString","query","requestKey","JSON","stringify","MockLink","_super","__extends","mockedResponses","options","Object","create","_this","call","showWarnings","mockedResponsesByKey","_a","forEach","mockedResponse","addMockedResponse","prototype","normalizedMockedResponse","normalizeMockedResponse","key","push","operation","unmatchedVars","requestVariables","variables","responseIndex","findIndex","res","index","mockedResponseVars","variableMatcher","response","delay","Infinity","configError","Error","concat","length","map","d","join","console","warn","message","maxUsageCount","splice","newData","result","error","observer","timer","setTimeout","onError","next","complete","clearTimeout","newMockedResponse","queryWithoutClientOnlyDirectives","name","normalizeVariableMatching","__assign","vars","mockedResponseVariables","mockSingleLink","_i","arguments","maybeTypename","mocks","slice"],"sources":["C:\\Users\\Simon\\IdeaProjects\\movie-theater-ticket-reservation\\frontend\\node_modules\\@apollo\\src\\testing\\core\\mocking\\mockLink.ts"],"sourcesContent":["import { invariant } from \"../../../utilities/globals/index.js\";\n\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  Operation,\n  GraphQLRequest,\n  FetchResult,\n} from \"../../../link/core/index.js\";\nimport { ApolloLink } from \"../../../link/core/index.js\";\n\nimport {\n  Observable,\n  addTypenameToDocument,\n  removeClientSetsFromDocument,\n  cloneDeep,\n  stringifyForDisplay,\n  print,\n  getOperationDefinition,\n  getDefaultValues,\n  removeDirectivesFromDocument,\n  checkDocument,\n} from \"../../../utilities/index.js\";\nimport type { Unmasked } from \"../../../masking/index.js\";\n\n/** @internal */\ntype CovariantUnaryFunction<out Arg, out Ret> = { fn(arg: Arg): Ret }[\"fn\"];\n\nexport type ResultFunction<T, V = Record<string, any>> = CovariantUnaryFunction<\n  V,\n  T\n>;\n\nexport type VariableMatcher<V = Record<string, any>> = CovariantUnaryFunction<\n  V,\n  boolean\n>;\n\nexport interface MockedResponse<\n  // @ts-ignore\n  out TData = Record<string, any>,\n  out TVariables = Record<string, any>,\n> {\n  request: GraphQLRequest<TVariables>;\n  maxUsageCount?: number;\n  result?:\n    | FetchResult<Unmasked<TData>>\n    | ResultFunction<FetchResult<Unmasked<TData>>, TVariables>;\n  error?: Error;\n  delay?: number;\n  variableMatcher?: VariableMatcher<TVariables>;\n  newData?: ResultFunction<FetchResult<Unmasked<TData>>, TVariables>;\n}\n\nexport interface MockLinkOptions {\n  showWarnings?: boolean;\n}\n\nfunction requestToKey(request: GraphQLRequest, addTypename: Boolean): string {\n  const queryString =\n    request.query &&\n    print(addTypename ? addTypenameToDocument(request.query) : request.query);\n  const requestKey = { query: queryString };\n  return JSON.stringify(requestKey);\n}\n\nexport class MockLink extends ApolloLink {\n  public operation!: Operation;\n  public addTypename: Boolean = true;\n  public showWarnings: boolean = true;\n  private mockedResponsesByKey: { [key: string]: MockedResponse[] } = {};\n\n  constructor(\n    mockedResponses: ReadonlyArray<MockedResponse<any, any>>,\n    addTypename: Boolean = true,\n    options: MockLinkOptions = Object.create(null)\n  ) {\n    super();\n    this.addTypename = addTypename;\n    this.showWarnings = options.showWarnings ?? true;\n\n    if (mockedResponses) {\n      mockedResponses.forEach((mockedResponse) => {\n        this.addMockedResponse(mockedResponse);\n      });\n    }\n  }\n\n  public addMockedResponse(mockedResponse: MockedResponse) {\n    const normalizedMockedResponse =\n      this.normalizeMockedResponse(mockedResponse);\n    const key = requestToKey(\n      normalizedMockedResponse.request,\n      this.addTypename\n    );\n    let mockedResponses = this.mockedResponsesByKey[key];\n    if (!mockedResponses) {\n      mockedResponses = [];\n      this.mockedResponsesByKey[key] = mockedResponses;\n    }\n    mockedResponses.push(normalizedMockedResponse);\n  }\n\n  public request(operation: Operation): Observable<FetchResult> | null {\n    this.operation = operation;\n    const key = requestToKey(operation, this.addTypename);\n    const unmatchedVars: Array<Record<string, any>> = [];\n    const requestVariables = operation.variables || {};\n    const mockedResponses = this.mockedResponsesByKey[key];\n    const responseIndex =\n      mockedResponses ?\n        mockedResponses.findIndex((res, index) => {\n          const mockedResponseVars = res.request.variables || {};\n          if (equal(requestVariables, mockedResponseVars)) {\n            return true;\n          }\n          if (res.variableMatcher && res.variableMatcher(operation.variables)) {\n            return true;\n          }\n          unmatchedVars.push(mockedResponseVars);\n          return false;\n        })\n      : -1;\n\n    const response =\n      responseIndex >= 0 ? mockedResponses[responseIndex] : void 0;\n\n    // There have been platform- and engine-dependent differences with\n    // setInterval(fn, Infinity), so we pass 0 instead (but detect\n    // Infinity where we call observer.error or observer.next to pend\n    // indefinitely in those cases.)\n    const delay = response?.delay === Infinity ? 0 : response?.delay ?? 0;\n\n    let configError: Error;\n\n    if (!response) {\n      configError = new Error(\n        `No more mocked responses for the query: ${print(operation.query)}\nExpected variables: ${stringifyForDisplay(operation.variables)}\n${\n  unmatchedVars.length > 0 ?\n    `\nFailed to match ${unmatchedVars.length} mock${\n      unmatchedVars.length === 1 ? \"\" : \"s\"\n    } for this query. The mocked response had the following variables:\n${unmatchedVars.map((d) => `  ${stringifyForDisplay(d)}`).join(\"\\n\")}\n`\n  : \"\"\n}`\n      );\n\n      if (this.showWarnings) {\n        console.warn(\n          configError.message +\n            \"\\nThis typically indicates a configuration error in your mocks \" +\n            \"setup, usually due to a typo or mismatched variable.\"\n        );\n      }\n    } else {\n      if (response.maxUsageCount && response.maxUsageCount > 1) {\n        response.maxUsageCount--;\n      } else {\n        mockedResponses.splice(responseIndex, 1);\n      }\n      const { newData } = response;\n      if (newData) {\n        response.result = newData(operation.variables);\n        mockedResponses.push(response);\n      }\n\n      if (!response.result && !response.error && response.delay !== Infinity) {\n        configError = new Error(\n          `Mocked response should contain either \\`result\\`, \\`error\\` or a \\`delay\\` of \\`Infinity\\`: ${key}`\n        );\n      }\n    }\n\n    return new Observable((observer) => {\n      const timer = setTimeout(() => {\n        if (configError) {\n          try {\n            // The onError function can return false to indicate that\n            // configError need not be passed to observer.error. For\n            // example, the default implementation of onError calls\n            // observer.error(configError) and then returns false to\n            // prevent this extra (harmless) observer.error call.\n            if (this.onError(configError, observer) !== false) {\n              throw configError;\n            }\n          } catch (error) {\n            observer.error(error);\n          }\n        } else if (response && response.delay !== Infinity) {\n          if (response.error) {\n            observer.error(response.error);\n          } else {\n            if (response.result) {\n              observer.next(\n                typeof response.result === \"function\" ?\n                  response.result(operation.variables)\n                : response.result\n              );\n            }\n            observer.complete();\n          }\n        }\n      }, delay);\n\n      return () => {\n        clearTimeout(timer);\n      };\n    });\n  }\n\n  private normalizeMockedResponse(\n    mockedResponse: MockedResponse\n  ): MockedResponse {\n    const newMockedResponse = cloneDeep(mockedResponse);\n    const queryWithoutClientOnlyDirectives = removeDirectivesFromDocument(\n      [{ name: \"connection\" }, { name: \"nonreactive\" }, { name: \"unmask\" }],\n      checkDocument(newMockedResponse.request.query)\n    );\n    invariant(queryWithoutClientOnlyDirectives, \"query is required\");\n    newMockedResponse.request.query = queryWithoutClientOnlyDirectives!;\n    const query = removeClientSetsFromDocument(newMockedResponse.request.query);\n    if (query) {\n      newMockedResponse.request.query = query;\n    }\n\n    mockedResponse.maxUsageCount = mockedResponse.maxUsageCount ?? 1;\n    invariant(\n      mockedResponse.maxUsageCount > 0,\n      `Mock response maxUsageCount must be greater than 0, %s given`,\n      mockedResponse.maxUsageCount\n    );\n\n    this.normalizeVariableMatching(newMockedResponse);\n    return newMockedResponse;\n  }\n\n  private normalizeVariableMatching(mockedResponse: MockedResponse) {\n    const request = mockedResponse.request;\n    if (mockedResponse.variableMatcher && request.variables) {\n      throw new Error(\n        \"Mocked response should contain either variableMatcher or request.variables\"\n      );\n    }\n\n    if (!mockedResponse.variableMatcher) {\n      request.variables = {\n        ...getDefaultValues(getOperationDefinition(request.query)),\n        ...request.variables,\n      };\n      mockedResponse.variableMatcher = (vars) => {\n        const requestVariables = vars || {};\n        const mockedResponseVariables = request.variables || {};\n        return equal(requestVariables, mockedResponseVariables);\n      };\n    }\n  }\n}\n\nexport interface MockApolloLink extends ApolloLink {\n  operation?: Operation;\n}\n\n// Pass in multiple mocked responses, so that you can test flows that end up\n// making multiple queries to the server.\n// NOTE: The last arg can optionally be an `addTypename` arg.\nexport function mockSingleLink(...mockedResponses: Array<any>): MockApolloLink {\n  // To pull off the potential typename. If this isn't a boolean, we'll just\n  // set it true later.\n  let maybeTypename = mockedResponses[mockedResponses.length - 1];\n  let mocks = mockedResponses.slice(0, mockedResponses.length - 1);\n\n  if (typeof maybeTypename !== \"boolean\") {\n    mocks = mockedResponses;\n    maybeTypename = true;\n  }\n\n  return new MockLink(mocks, maybeTypename);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}